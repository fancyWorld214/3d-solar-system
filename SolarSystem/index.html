<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<title>CGV-Aufgabe 1</title>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="hand.js"></script>
	<style type="text/css">
		html,
		body,
		canvas {
			width: 100%;
			height: 95%;
			padding: 0;
			margin: 0;
			overflow: hidden;
		}

		#renderCanvas {
			display: none;
		}

		#btn {
			color: black;
			font-display: block;
		}

		#video {
			display: none;
		}
	</style>
</head>

<body>
	<!-- 若需触发画中画，必须用户侧有相应的动作，无法直接从js代码触发 -->
	<button id="btn">Start</button>
	<canvas id="overallCanvas"></canvas>
	<canvas id="renderCanvas"></canvas>
	<video id="video" autoplay></video>

	<script>
		// Check support
		if (!BABYLON.Engine.isSupported()) {
			window.alert('Browser not supported');
		} else {
			// 初始化场景要素
			var canvas0 = document.getElementById("overallCanvas");
			var canvas1 = document.getElementById("renderCanvas");
			var engine0 = new BABYLON.Engine(canvas0, true);
			var scene0 = new BABYLON.Scene(engine0);
			var engine1 = new BABYLON.Engine(canvas1, true);
			var scene1 = new BABYLON.Scene(engine1);

			// 配置相机
			var camera1 = new BABYLON.ArcRotateCamera("camera1", 0, 0, 10, BABYLON.Vector3.Zero(), scene1);
			// Set the camera's position and target
			camera1.setPosition(new BABYLON.Vector3(0, 0, -10));
			camera1.setTarget(BABYLON.Vector3.Zero());
			// Attach the camera to the canvas
			camera1.attachControl(canvas1, true);

			var camera0 = new BABYLON.ArcRotateCamera("ArcRotateCamera", -Math.PI / 4.0, 0.25 * Math.PI, 1.5, new BABYLON.Vector3(0, 0, 0), scene0);
			// Attach the camera to the canvas
			camera0.attachControl(canvas0, true);

			// 配置场景
			setUp(engine0, scene0, canvas0, camera0, false, "");
			setUp(engine1, scene1, canvas1, camera1, true, "sun");

			// Kamera für VR mit Device Orientation zum Herumschauen 
			//var camera = new BABYLON.DeviceOrientationCamera("ArcRotateCamera", new BABYLON.Vector3(1, 1, 1), scene);
			//camera.setCameraRigMode(20,{interaxialDistance: 0.0637});




			// Show coordinate system, BabylonJS uses left-handed coordinates!
			// x-axis: red, y-axis: yellow, z-axis: green



			// Function to update the camera's position and target


			//scene.activeCamera.attachControl(canvas);
			// Render loop
			// var renderLoop = function () {
			// Start new frame
			//engine.beginFrame();

			//scene.render();

			// Present
			//engine.endFrame();

			// Register new frame
			//BABYLON.Tools.QueueNewFrame(renderLoop);
			//};
			//BABYLON.Tools.QueueNewFrame(renderLoop);

			//canvas1.requestPictureInPicture();
			// 将canvas转换为video
			const video = document.getElementById('video');

			// Create a MediaStream object from the canvas
			const stream = canvas1.captureStream();

			// Create a new MediaRecorder instance for recording video
			const recorder = new MediaRecorder(stream);

			// Create an array to store the recorded video chunks
			var chunks = [];

			// Listen for dataavailable event which is triggered when a video chunk is available
			recorder.addEventListener('dataavailable', (event) => {
				chunks.push(event.data);
			});

			// Listen for stop event which is triggered when recording has stopped
			recorder.addEventListener('stop', () => {

			});

			// Start recording the canvas
			recorder.start();

			// Stop recording after 5 seconds (adjust this according to your needs)
			setInterval(() => {

				// Create a Blob object from the recorded chunks
				const blob = new Blob(chunks, { type: 'video/webm' });
				recorder.stop();
				// Set the source of the video element to the recorded video
				const videoURL = URL.createObjectURL(blob);
				video.src = videoURL;
				chunks = [];
				recorder.start();

			}, 2000);

			//必须要video的metadata加载完成后才能进入画中画
			video.addEventListener('loadedmetadata', () => {
				// 在元数据加载完毕后调用 requestPictureInPicture 方法
				// 必须要有用户动作才能触发画中画，不可以直接用代码开启
				btn.addEventListener('click', () => {
					video.requestPictureInPicture()
						.then(() => {
							// 成功进入画中画模式
						})
						.catch((error) => {
							// 处理错误
							console.error('Failed to enter picture-in-picture mode:', error);
						});
				});
			});

			setUpCameraMovingPattern(camera0, scene0);


			// Resize
			window.addEventListener("resize", function () {
				engine0.resize();
			});
		};


		function setUp(engine, scene, canvas, camera, setUpParent, parent) {

			var diameterScale = 35;
			var sun_diameter = 1.3927 * diameterScale;
			var earth_diameter = 0.12756 * diameterScale;
			var moon_diameter = 5;
			var mars_diameter = 0.6794 * diameterScale;
			var jupiter_diameter = 14.392 * diameterScale;
			var neptune_diameter = 3.883 * diameterScale;

			var distanceScale = 1;
			// var earth_distance = 149.6 * distanceScale;
			var earth_distance = 20;
			var moon_distance = 0.9 * distanceScale;
			var mars_distance = 227.9 * distanceScale;
			var jupiter_distance = 778.6 * distanceScale;
			var neptune_distance = 4495 * distanceScale;


			//Bonusteil:3
			var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000.0 }, scene);
			var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
			skyboxMaterial.backFaceCulling = false;
			skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("assets/skybox/nebula", scene);
			skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
			skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
			skybox.material = skyboxMaterial;

			var sun = BABYLON.Mesh.CreateSphere("Sun", sun_diameter, 0.65, scene);
			var earth = BABYLON.Mesh.CreateSphere("Earth", earth_diameter, 0.3, scene);
			var moon = BABYLON.Mesh.CreateSphere("Moon", moon_diameter, 0.075, scene);

			if (setUpParent === true) {
				if (parent === "sun") {
					camera.parent = sun;
				}
			}

			//Bonusteil:2
			var mars = BABYLON.Mesh.CreateSphere("Mars", mars_diameter, 0.25, scene);
			var jupiter = BABYLON.Mesh.CreateSphere("Jupiter", jupiter_diameter, 0.35, scene);
			var neptune = BABYLON.Mesh.CreateSphere("Neptune", neptune_diameter, 0.37, scene);


			var material1 = new BABYLON.StandardMaterial("default1", scene);
			material1.diffuseTexture = new BABYLON.Texture("assets/earth.jpg", scene);
			material1.specularColor = new BABYLON.Color3(0, 0, 0);
			material1.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
			material1.diffuseTexture.vScale = -1;
			material1.diffuseTexture.uScale = -1;

			var material2 = new BABYLON.StandardMaterial("default2", scene);
			material2.diffuseTexture = new BABYLON.Texture("assets/moon.jpg", scene);
			material2.specularColor = new BABYLON.Color3(0, 0, 0);
			material2.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
			material1.diffuseTexture.vScale = -1;
			material1.diffuseTexture.uScale = -1;

			var material3 = new BABYLON.StandardMaterial("default3", scene);
			material3.diffuseTexture = new BABYLON.Texture("assets/sun.jpg", scene);
			material3.specularColor = new BABYLON.Color3(0, 0, 0);
			material3.emissiveColor = new BABYLON.Color3(1, 1, 1);

			var material4 = new BABYLON.StandardMaterial("default1", scene);
			material4.diffuseTexture = new BABYLON.Texture("assets/mars.jpg", scene);
			material4.specularColor = new BABYLON.Color3(0, 0, 0);
			material4.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
			material4.diffuseTexture.vScale = -1;
			material4.diffuseTexture.uScale = -1;

			var material5 = new BABYLON.StandardMaterial("default1", scene);
			material5.diffuseTexture = new BABYLON.Texture("assets/jupiter.jpg", scene);
			material5.specularColor = new BABYLON.Color3(0, 0, 0);
			material5.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
			material5.diffuseTexture.vScale = -1;
			material5.diffuseTexture.uScale = -1;

			var material6 = new BABYLON.StandardMaterial("default1", scene);
			material6.diffuseTexture = new BABYLON.Texture("assets/neptune.png", scene);
			material6.specularColor = new BABYLON.Color3(0, 0, 0);
			material6.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
			material6.diffuseTexture.vScale = -1;
			material6.diffuseTexture.uScale = -1;


			earth.material = material1;
			moon.material = material2;
			sun.material = material3;
			mars.material = material4;
			jupiter.material = material5;
			neptune.material = material6;

			var light = new BABYLON.PointLight("dir01", new BABYLON.Vector3(-0.0, -0.0, 0.0), scene);
			light.diffuse = new BABYLON.Color3(1.0, 1.0, 1.0);
			light.intensity = 1.0;

			scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.1);

			var d = new Date();
			var startTime = d.getTime();
			var lastTime = startTime;

			var sim_year = 1.0;                         // one simulated year in minutes
			var sim_month = sim_year / (365.24 / 27.3);
			var sim_day = sim_year / 365.24;

			var moon_local_pos = new BABYLON.Vector3((-1.0) * moon_distance, 0, 0);

			//console.log(sun.position);

			// Set initial earth position
			earth.position.x = earth_distance;
			earth.position.y = 0.0;
			earth.position.z = 0.0;

			// Set initial moon position
			moon.position.x = earth.position.x - moon_distance;
			moon.position.y = earth.position.y;
			moon.position.z = earth.position.z;


			// Set initial mars position
			mars.position.x = mars_distance
			mars.position.y = earth.position.y;
			mars.position.z = earth.position.z;


			// Set initial jupiter position
			jupiter.position.x = jupiter_distance;
			jupiter.position.y = earth.position.y;
			jupiter.position.z = earth.position.z;

			// Set initial neptune position
			neptune.position.x = neptune_distance;
			neptune.position.y = earth.position.y;
			neptune.position.z = earth.position.z;


			var earthSpeed = 0;
			var moonSpeed = 0;
			var earthOrbitRadius = earth_distance;
			var moonOrbitRadius = moon_distance;
			scene.beforeRender = function () {
				var incremental = false;
				var incremental_buggy = false;

				var d = new Date();
				var time = d.getTime();        // get milliseconds since 1970
				var elapsed_t = time - startTime;   // milliseconds since start
				var delta_t = lastTime - time;    // milliseconds since last frame
				lastTime = time;

				var min2ms = 1000.0 * 60.0;        // milliseconds in minutes
				var einUmlauf = 1 * min2ms;

				// Update earth position and rotation
				earthSpeed = ((elapsed_t % einUmlauf) * 360) / einUmlauf;
				var radians = earthSpeed * Math.PI / 180;
				earth.position.x = Math.cos(radians) * earthOrbitRadius;
				earth.position.z = Math.sin(radians) * earthOrbitRadius;

				earth.rotation.y = ((elapsed_t) * (360 * 365.24)) / min2ms / 1000;


				// Update moon position and rotation
				moonSpeed = ((elapsed_t % (einUmlauf)) * 360) / (27.3 * (einUmlauf / 365.24));
				var moonradians = moonSpeed * Math.PI / 180;
				moon.position.x = (Math.cos(moonradians) * moonOrbitRadius) + earth.position.x;
				moon.position.z = (Math.sin(moonradians) * moonOrbitRadius) + earth.position.z;

				moon.rotation.y = ((elapsed_t) * (360 * 27.3)) / min2ms;

				// Update other planets position and rotation
				mars.position.x = Math.cos(radians * 1.3) * mars_distance;
				mars.position.z = Math.sin(radians * 1.3) * mars_distance;

				jupiter.position.x = Math.cos(radians * 1.2) * jupiter_distance;
				jupiter.position.z = Math.sin(radians * 1.2) * jupiter_distance;

				neptune.position.x = Math.cos(radians * 0.9) * neptune_distance;
				neptune.position.z = Math.sin(radians * 0.9) * neptune_distance;

				//console.log("Earth position: " + moon.position);
				//console.log(BABYLON.Tools.GetFps().toFixed() + " fps");
			};
			if (setUpParent === true && parent === "sun") {
				camera.fov = 0.5;
				function updateCamera() {
					// Calculate the direction from the Earth to the Sun
					var direction = BABYLON.Vector3.Normalize(earth.position.subtract(sun.position));
					//console.log(`earth.position: ${earth.position}`)
					//console.log(`camera: ${camera}`)
					// Set the camera's position relative to the Earth (adjust this value based on your desired camera distance)
					camera.position = earth.position.add(direction.scale(0.8));

					// Set the camera's target to always look at the Sun
					camera.setTarget(sun.position);
				}

				// Register the update function to be called every frame
				scene.registerBeforeRender(updateCamera);
			}


			engine.runRenderLoop(function () {
				scene.render();
			}
			);
		}

		function setUpCameraMovingPattern(camera, scene) {
			// Define the movement speed for the camera
			var cameraSpeed = 1;

			// Add event listeners to detect key presses
			window.addEventListener("keydown", function (event) {
				var keyCode = event.keyCode;

				// Move forward (W key)
				if (keyCode === 87) {
					moveCameraForward();
				}

				// Move backward (S key)
				if (keyCode === 83) {
					moveCameraBackward();
				}

				// Move left (A key)
				if (keyCode === 65) {
					moveCameraLeft();
				}

				// Move right (D key)
				if (keyCode === 68) {
					moveCameraRight();
				}
			});

			// Helper functions to move the camera
			function moveCameraForward() {
				var direction = camera.getDirection(BABYLON.Axis.Z);
				camera.position.addInPlace(direction.scaleInPlace(-cameraSpeed));
			}

			function moveCameraBackward() {
				var direction = camera.getDirection(BABYLON.Axis.Z);
				camera.position.addInPlace(direction.scaleInPlace(cameraSpeed));
			}

			function moveCameraLeft() {
				var direction = camera.getDirection(BABYLON.Axis.Z);
				var sideDirection = BABYLON.Vector3.Cross(direction, camera.upVector);
				camera.position.addInPlace(sideDirection.scaleInPlace(-cameraSpeed));
			}

			function moveCameraRight() {
				var direction = camera.getDirection(BABYLON.Axis.Z);
				var sideDirection = BABYLON.Vector3.Cross(direction, camera.upVector);
				camera.position.addInPlace(sideDirection.scaleInPlace(cameraSpeed));
			}
		}
	</script>
</body>

</html>